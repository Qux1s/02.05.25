Минусы фиксированного массива 
               1.фиксированные массивы не могут иметь длину, 
               основанную ни на входных данных пользователя, ни на каком-либо другом значении, вычисленном во время выполнения;
               2.фиксированные массивы имеют фиксированную длину, которую нельзя изменить.
Во многих случаях эти ограничения проблематичны. 
К счастью, C++ поддерживает второй тип массивов, известный как динамический массив. 
Длину динамического массива можно установить во время выполнения, и ее можно изменить. 
Однако создание динамических массивов немного сложнее, поэтому мы рассмотрим их позже в этой главе.
Массив при передаче в функцию не копируется а передаетсся исходный массив
Чтобы функция не изменяла параметры массива можно сделатть его константным  void passArray(const int prime[5])
std::size() будет работать и с другими типами объектов (такими как std::array и std::vector), и она вызовет ошибку компиляции, если вы попытаетесь использовать ее с фиксированным массивом, который был передан в функцию!
Небольшой трюк: мы можем определить длину фиксированного массива, разделив размер всего массива на размер элемента массива   std::cout << "The array has: " << sizeof(array) / sizeof(array[0]) << " elements\n";
               Динамические массивы почти ничем не отличаются от фиксированных за исключением того что нужно их чистить delete[]
              Фиксированные массивы распадаются на указатели, при этом теряется информация о длине массива, а у динамических массивов возникают проблемы с освобождением памяти и их сложно изменить без допущения ошибок
              std::array обеспечивает функциональность фиксированного массива, которая не пропадает при передаче в функцию. std::array определяется в заголовке <array> внутри пространства имен std.
              К сожалению, std::to_array дороже, чем создание std::array напрямую, потому что она фактически копирует все элементы из массива в стиле C в std::array. 
              По этой причине следует избегать использования std::to_array, когда массив создается много раз (например, в цикле).
              std::array поддерживает вторую форму доступа к элементам массива (функция at()), которая выполняет проверку границ:
              std::array будет очищаться, когда выходит за пределы области видимости, поэтому нет необходимости выполнять какую-либо ручную очистку.
              Поскольку std::array не раскладывается на указатель при передаче в функцию, функция size() будет работать, даже если вы вызовете ее из функции:

Резюме
std::array – отличная замена встроенным фиксированным массивам. 
Он эффективен, поскольку использует памяти не больше, чем встроенные фиксированные массивы. 
Единственный реальный недостаток std::array, по сравнению со встроенным фиксированным массивом, – это немного более неудобный синтаксис, 
в котором вам нужно явно указать длину массива (компилятор не будет рассчитывать ее из инициализатора вместо вас, если вы также не опустите тип, что не всегда возможно), 
и проблемы «со знаком / без знака» с размером и индексированием. Но это сравнительно незначительные 
придирки – мы рекомендуем использовать std::array вместо встроенных фиксированных массивов для любого нетривиального использования массива.


VECTOR
Представленный в C++03, std::vector предоставляет функциональность динамического массива, которая обеспечивает собственное управление памятью.
В отличие от встроенных динамических массивов, которые не знают длину массива, на который они указывают, std::vector отслеживает свою длину. Мы можем запросить длину вектора с помощью функции size():
У std::vector есть еще один крутой трюк. Существует специальная реализация для std::vector типа bool, которая сжимает 8 логических значений в один байт! 
Это происходит за кулисами и не меняет способ использования std::vector.
Заключение
Поскольку переменные типа std::vector обеспечивают собственное управление памятью (что помогает предотвратить утечки памяти), 
запоминают свою длину и могут легко изменять размер, мы рекомендуем использовать std::vector в большинстве случаев, когда необходимы динамические массивы.
